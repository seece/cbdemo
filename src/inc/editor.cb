// sync editor
//
// hotkeys: HOLD CTRL	move all nodes to the right
// 			HOLD ALT	disable snapping
//			HOLD X		click to remove nodes
//			DEL			when holding node, deletes node
//			RIGHT CLICK	add node
//			F6			save current track
//			F9			load current track
//			A and D		move on the timeline (hold shift for speed boost)
//			W and S		zoom in and out	(hold shift for speed boost)

// config

// #define STANDALONE_EDITOR		// compile with main loop etc.
//  #define USE_EDITOR_COMPONENTS	// if this is disabled, only compiles the parts needed for playing back data
//  #define UI_BUTTONSTRIP_WIDTH 150	// oikean laidan toimintonappulat

// macros

// #define malloc(size) makeMEMBlock(size)
// #define free deleteMEMBlock
// #define realloc resizeMEMBlock
// #define toType(integer) convertToType(integer)
// #define toInt(typevar) convertToInteger(typevar)
// #define assert(statement) If Not (statement) Then makeError __LINE__ + ": assertion failed"

// #define frac(_var) (_var-roundDown(_var))
// #define round(_val) ()
// #define lerp(_val1, _val2, _amount) (_val1 + (_val2 - _val1) * _amount)
// #define barsToSecs(_bars, _tempo) (_bars * ((60.0/_tempo)*4.0))
// #define snapToGrid(_value, _size) (int(_value/_size)*_size)
// #define clamp(_val) (max(0.0,min(1.0, _val)))

// #define POINT_STRIDE 8
// #define UNDEFINED -1

// #define UI_POINT_SIZE 8
// #define UI_COLOR_DARK 24, 24, 30
// #define UI_COLOR_BG 50, 50,64
// #define UI_COLOR_DIM 80,80,80
// #define UI_COLOR_BG_FOCUS 64,64,70
// #define UI_COLOR_RIM 128,128,128
// #define UI_COLOR_LIGHT 255, 255, 255
// #define UI_COLOR_HILIGHT 240, 230, 210
// #define UI_COLOR_MID 140, 130, 128

// #define mouseOverlap(_x,_y,_w,_h) (mouseX() >= (_x) and mouseX() <= ((_x) + (_w)) and mouseY() >= (_y) and mouseY() <= ((_y) + (_h)))
// #define toggle(x) (x xor 1)
// #define confirmDialog(_message) dialog(mouseX(), mouseY() - 100, _message)	// shows a dialog above mouse position


type Synctrack
	// memblock data format
	// each entry is a datapoint as two float vars
	// offset	length	desc
	// 0		4		the point time as bars, 32-bit float
	// 4		4		the points value, a float between 0-1 (inclusive)
	field mem	// memblock
	field count
	field name as string
endType

type Envpoint
	field bars as float
	field value as float
	field index
endType

// #ifdef USE_EDITOR_COMPONENTS
type EnvEditor
	field selectedPoint // just an id
	field deletePoint	// we'll delete the point usually ON the next frame
	field x
	field y
	field width
	field height
	field startpos#
	field endpos#
	field track
	field hover
	field snapsize as float
	field gridsize as float
	field timelineHeight 
endType

type TrackSelector
	field x
	field y
	field width
	field height
	field count
	field selectedTrack	// track id
	field trackNames as string
endType
// #endif

//#pragma dumb_debug




















































































































































































function loadTrack(trackp, filename$)
	track.Synctrack = convertToType(trackp)
	
	bytes_read = 0
	offset = 0
	file_size = fileSize(filename)

	if not fileExists (filename) then return bytes_read
	
	memblock = makeMEMBlock(file_size)
	
	f = openToRead(filename)
	
	while not EOF(f)
		char = readByte(f)
		pokeByte memblock, offset, char
		offset = offset + 1
		//bars# = readFloat(f)
		//value# = readFloat(f)
	wend
	
	bytes_read = fileOffset(f)
	closeFile(f)

	deleteMEMBlock track\mem
	track\count = (bytes_read/8)
	track\mem = memblock

	return bytes_read
endFunction

// #ifdef USE_EDITOR_COMPONENTS

// message dialog with OK and CANCEL buttons
// freezes the program execution until exit
function dialog(pos_x, pos_y, message$)	
	margin = 8
	dialogwidth = max(220, textWidth(message$) + margin*2)
	dialogheight = 100
	real_x = max(0, min(pos_x, screenWidth() - dialogwidth))
	real_y = max(0, min(pos_y, screenHeight() - dialogheight))
	okwidth = min(50, dialogwidth * 0.4)
	okheight = 24
	
	repeat
		color 24, 24, 30
		box real_x, real_y, dialogwidth, dialogheight, 1
		
		color 255, 255, 255
		text real_x + dialogwidth/2 - textWidth(message$)/2, real_y + dialogheight * 0.4, message$
		btn_ok = textButton(real_x + dialogwidth - margin - okwidth, real_y + dialogheight - margin - okheight, okwidth, okheight, "OK", false)
		btn_cancel = textButton(real_x + dialogwidth - margin*2 - okwidth*2, real_y + dialogheight - margin - okheight, okwidth, okheight, "cancel", false)
		
		if btn_ok then return true
		if btn_cancel then return false
		drawScreen OFF
	forever
endFunction

function textButton(pos_x, pos_y, width, height, caption$, held_down)
	hover = false
	clicked = false
	
	if (mouseX() >= (pos_x) and mouseX() <= ((pos_x) + ( width)) and mouseY() >= ( pos_y) and mouseY() <= (( pos_y) + ( height))) then hover = true
	
	if hover and mouseDown(1) then clicked = true
	
	button_x = pos_x
	button_y = pos_y + (clicked or held_down)
	
	if clicked or held_down then
		color 64,64,70
	else
		color 80,80,80
	endif
	
	box button_x, button_y, width, height, true
	
	if hover then
		color 128,128,128
		
		if clicked then color 24, 24, 30
	else
		color 24, 24, 30
	endif
	
	box button_x, button_y, width, height, false 
	
	if clicked or held_down then
		color 140, 130, 128
	else
		color 240, 230, 210
	endif
	text button_x + (width/2) - textWidth(caption$)/2, button_y + (height/2) - textHeight(caption$)/2, caption$
	
	if hover and mouseUp(1) then return true
	
	return false
	
endFunction

function createTrackSelector(x,y,w,h,amountOfTracks)
	selector.TrackSelector = new (TrackSelector)
	selector\count = amountOfTracks

	If Not (amountOfTracks > 0) Then makeError 383 + ": assertion failed"

	selector\x = x
	selector\y = y
	selector\width = w
	selector\height = h

	return convertToInteger(selector)
endFunction

function drawTrackSelector(selectorp)
	If Not (selectorp <> -1) Then makeError 394 + ": assertion failed"
	
	selector.TrackSelector = convertToType(selectorp)
	buttonsize# = selector\width / selector\count
	buttonsize = min(150, buttonsize)	// maximum width for the button
	
	for i=0 to selector\count - 1
		caption$ = str(i)

		if not selector\trackNames = "" then
			trackname$ = getWord(selector\trackNames, i+1, "|")
			if (not trackname = "") and (textWidth(trackname) < buttonsize) then caption = trackname
		endif
		
		button_x = selector\x + i * buttonsize 
		button_y = selector\y 
		held = false
		if i = selector\selectedTrack then held = true
		clicked = textButton(button_x, button_y, buttonsize, selector\height, caption, held)
		
		if clicked then selector\selectedTrack = i
	next i
endFunction

// returns the amount of bytes written
function saveTrack(trackp, filename$)
	track.Synctrack = convertToType(trackp)

	f = openToWrite(filename)
	
	for i=0 to track\count-1
		offset = i * 8
		writeFloat f, peekFloat(track\mem, offset)
		writeFloat f, peekFloat(track\mem, offset + 4)
	next i
	
	written = fileOffset(f)
	closeFile(f)
	
	return written
endFunction


function createEnvEditor(x,y,w,h,startspan,endspan)
	editor.EnvEditor = new(EnvEditor)
	editor\x = x
	editor\y = y
	editor\width = w
	editor\height = h
	editor\startpos = startspan
	editor\endpos = endspan
	editor\track = -1
	editor\selectedPoint = -1 
	editor\hover = false
	editor\deletePoint = -1 
	editor\snapsize = 0.5
	editor\gridsize = 1.0
	editor\timelineHeight = 20
	return convertToInteger(editor)
endFunction

function updateEditor(editorp, bars#)
	editor.EnvEditor = convertToType(editorp)
	mousedz# = mouseMoveZ()
	scrollspeed#  = 0.7
	
	origpos# = editor\startpos

	speedboost# = 1.0
	if keyDown(42) then speedboost = 2.5	// left shift

	if keyDown(cbKeyA) then	
		editor\startpos = max(editor\startpos - scrollspeed * speedboost, 0.0)
		editor\endpos = editor\endpos - (origpos - editor\startpos)
	elseIf keyDown(cbKeyD) then
		editor\startpos = editor\startpos + scrollspeed * speedboost
		editor\endpos = editor\endpos + scrollspeed * speedboost
	endif
	
	span# = editor\endpos - editor\startpos
	middle# = editor\startpos + span*0.5
	zoom# = mousedz * 1.2

	if keyDown(cbKeyW) then zoom = 0.2 * speedboost
	if keyDown(cbKeyS) then zoom = -0.2	* speedboost
	
	editor\startpos = editor\startpos + zoom#
	editor\endpos = editor\endpos - zoom#
	
	editor\startpos = max(0.0, editor\startpos)
	
	if editor\endpos - editor\startpos < 1.0
		editor\endpos = editor\startpos + 1.0
	endif

	
	if editor\deletePoint <> -1 then
		// deleteEnvpoint(trackint, index)
		deleteEnvpoint(editor\track, editor\deletePoint)
		editor\deletePoint = -1
	endif
	
	return bars
endFunction

function drawEditor(editorp, bars#)
	editor.EnvEditor = convertToType(editorp)
	mx# = mouseX()
	my# = mouseY()
	mousedz# = mouseMoveZ()
	
	span# = editor\endpos - editor\startpos
	hover = false
	thisfirst = true
	lastx# = 0
	lasty# = 0
	
	gridspacing# = editor\gridsize
	bar_width_in_px# = editor\width / span
	grid_lines = roundDown(span/gridspacing)
	grid_size# = gridspacing * bar_width_in_px
	grid_start_x = bar_width_in_px - (int(editor\startpos * bar_width_in_px) mod int(bar_width_in_px))
	
	track.Synctrack = convertToType(editor\track)
	
	if (mouseX() >= (editor\x) and mouseX() <= ((editor\x) + ( editor\width)) and mouseY() >= ( editor\y) and mouseY() <= (( editor\y) + ( editor\height))) then
		hover = true
		editor\hover = true
	else
		editor\hover = false
	endif
	
	if keydown(cbKeyLAlt) then snap = false else snap = true
	snapsize# = editor\snapsize
	
	// render bg
	
	color 50, 50,64
	
	box editor\x, editor\y, editor\width, editor\height, 1
	
	if hover then
		color 128,128,128
	else
		color 80,80,80
	endif
	box editor\x, editor\y, editor\width, editor\height, 0	
	
	if editor\track = -1 then 
		return false
	endif
	
	// render grid
	color 64,64,70
	for i=0 to grid_lines
		line_x = grid_start_x + i * grid_size
		line line_x, editor\y, line_x, editor\y + editor\height
	next i	
	
	// render time marker
	marker_x_pos = editor\x + (bars - editor\startpos) * bar_width_in_px
	if bars >= editor\startpos and bars <= editor\endpos then
		color 240, 230, 210
		line marker_x_pos, editor\y, marker_x_pos, editor\y + editor\height + editor\timelineHeight
		
	endif
	
	spointp = firstPointAfter(editor\track, editor\startpos)
	ipointp = spointp
	
	if ipointp = -1 then
		track.SyncTrack = convertToType(editor\track)
		spointp = getEnvPoint(editor\track, track\count- 1)
		ipointp = spointp
		//return false
	endif
	
	spoint.Envpoint = convertToType(spointp)
		
	// we take one to the left to only render also the point over to the left hand side of the SCREEN
	if spoint\index > 0 then
		spointp = getEnvPoint(editor\track, spoint\index - 1)
		ipointp = spointp
		spoint = convertToType(spointp)
	endif
	
	ipoint.Envpoint = spoint
	ind = ipoint\index
			
	// current mouse position
	newbars# = editor\startpos + ((mx-editor\x)/editor\width) * span
	newvalue# = 1.0 - ((my-editor\y)/editor\height) * 1.0
	
	if snap then
		newbars = (int(newbars/ snapsize)* snapsize)
	endif
	
	// a new point!
	if mouseHit(2) and hover then
		before_pointp = firstPointBefore(editor\track, newbars)
		if before_pointp = -1 then
			// TODO write error to log
		else
			before_point.EnvPoint = convertToType(before_pointp)
			temp_point.EnvPoint = new(EnvPoint)
			temp_point\bars = newbars
			temp_point\value = (max(0.0,min(1.0, newvalue)))
			
			addEnvelopePoint(editor\track, convertToInteger(temp_point), before_point\index + 1)
			
			delete temp_point
			delete before_point
		endif
	endif
	
	// a flag used to detect when we want to lose focus
	clicked_on_point = false

	while (ind < track\count)
		pointhover = false
		delete_current_point = false
		px# = editor\x + ((ipoint\bars - editor\startpos)/span) * editor\width
		py# = editor\y + editor\height - ipoint\value * editor\height
		
		if not thisfirst then
			color 140, 130, 128
			line lastx, lasty, px, py
		endif
		
		// we have processed all visible points
		if px > editor\x + editor\width then
			exit
		endif
		
		if ind=editor\selectedPoint then
			pointhover = drawPoint(px, py, true)
		else
			pointhover = drawPoint(px, py, false)
		endif
			
		if pointhover and mouseHit(1) then 
			editor\selectedPoint = ind
			clicked_on_point = true
		endif
		
		if mouseUp(1) then editor\selectedPoint = -1

		if ind=editor\selectedPoint and editor\selectedPoint <> -1 then	
		
			if newvalue > 1.0 then newvalue = 1.0
			if newvalue < 0.0 then newvalue = 0.0
			
			if ind = 0 then
				if newbars < 0.0 then newbars = 0.0
			else
				// not the first one, let's inspect neighbours
				lpointp = getEnvpoint(editor\track, ind-1)
				lpoint.EnvPoint = convertToType(lpointp)
				if newbars < lpoint\bars then newbars = lpoint\bars
				
				// the right neighbour
				if ind < track\count-1 then
					rpointp = getEnvpoint(editor\track, ind+1)
					rpoint.EnvPoint = convertToType(rpointp)
					if newbars > rpoint\bars then newbars = rpoint\bars
					delete rpoint
				endif
				
				delete lpoint
			endif

			oldbars# = ipoint\bars
			oldvalue# = ipoint\value
			// setup temporary type instance
			ipoint\bars = newbars
			ipoint\value = newvalue
			
			// actually save the value to the array
			setEnvpoint(editor\track, convertToInteger(ipoint), ipoint\index)
			
			if keyDown(cbkeylcontrol) then
				moveAllPointsFrom(editor\track, ipoint\index+1, ipoint\bars - oldbars)
			endif
			
			color 140, 130, 128
			text px + 15, py + 15, "" + ipoint\bars + ", " + ipoint\value
			
			if keyHit(cbKeyDel) or (pointhover and mouseDown(1) and keyDown(cbKeyX)) then
				editor\deletePoint = ipoint\index
				editor\selectedPoint = -1
			endif
		endif			
		
		thisfirst = false
		lastx = px
		lasty = py
		
		if ind+1 >= track\count then exit
		
		delete ipoint
		ipoint = getEnvpoint(editor\track, ind+1)
		ind = ipoint\index
	wend		
	
	delete ipoint
	
	color 140, 130, 128
	text editor\x + 4, editor\y + 4, editor\startpos + " - " + editor\endpos

endFunction

function drawEditorTimeline(editorp, bars#)
	editor.EnvEditor = convertToType(editorp)
	mx# = mouseX()
	my# = mouseY()
	mousedz# = mouseMoveZ()
	newbars# = bars
	
	span# = editor\endpos - editor\startpos
	
	tl_x = editor\x
	tl_y = editor\y + editor\height
	tl_w = editor\width
	tl_h = editor\timelineHeight
	
	hover = false
	
	if (mouseX() >= (tl_x) and mouseX() <= ((tl_x) + ( tl_w)) and mouseY() >= ( tl_y) and mouseY() <= (( tl_y) + ( tl_h))) then
		hover = true
	endif

	if hover and mouseDown(1) and editor\selectedPoint = -1 then
		newpos# = editor\startpos + ((mx-editor\x)/editor\width) * span
		newbars = newpos
	endif
	
	// bg box
	color 50, 50,64
	box tl_x, tl_y, tl_w, tl_h
	
	// mouse marker
	if hover then
		color 128,128,128
		line mx, tl_y, mx, tl_y + tl_h
	endif
	
	// draw the numbers
	gridspacing# = 1.0
	bar_width_in_px# = editor\width / span
	grid_lines = roundDown(span/gridspacing)
	grid_size# = gridspacing * bar_width_in_px
	grid_start_x = bar_width_in_px - (int(editor\startpos * bar_width_in_px) mod int(bar_width_in_px))

	
	for i=-1 to grid_lines step 1
		num_x = grid_start_x + i * grid_size
		num =  roundDown(editor\startpos) + int(i*gridspacing) + 1
		color 24, 24, 30
		text num_x, tl_y + 2, num
		color 140, 130, 128
		text num_x, tl_y + 1, num
		//line line_x, editor\y, line_x, editor\y + editor\height
	next i	
	
	return newbars
endFunction

function drawPoint(x,y,selected)
	hover = false
	
	margin = 3
	if (mouseX() >= (x-margin -8/2) and mouseX() <= ((x-margin -8/2) + ( 8 + margin*2)) and mouseY() >= ( y-margin -8/2) and mouseY() <= (( y-margin -8/2) + ( 8 + margin*2))) then
		hover = true
	endif

	if hover or selected
		color 128,128,128
		box x - 8/2-2, y - 8/2-2, 8 + 4, 8 + 4, OFF
	endif

	if selected = 0 then
		color 128,128,128
	elseIf selected = 1
		color 255, 255, 255
	endif
	
	
	
	box x - 8/2, y - 8/2, 8, 8
	
	return hover
endFunction

function moveAllPointsFrom(trackp, index, amount#)
	track.Synctrack = convertToType(trackp)
	if index >= track\count then
		return false
	endif
	
	ind = index
	while (ind < track\count)
		// setEnvpointValue(trackint, newbars#, newvalue#, index)
		pointp = getEnvpoint(trackp, ind)
		point.EnvPoint = convertToType(pointp)
		point\bars = point\bars + amount
		setEnvpoint(trackp, pointp, ind)
		delete point
		ind + 1
	wend
	
	return true
endFunction


// index tells the place where to insert the new point
// returns void
function addEnvelopePoint(trackint, envint, index)
	track.Synctrack = convertToType(trackint)
	point.Envpoint = convertToType(envint)
	
	offset = index * 8
	movesize = (MEMBlockSize(track\mem))-offset
	
	resizeMEMBlock track\mem, MEMBlockSize(track\mem) + 8
	
	If Not (index <= track\count) Then makeError 819 + ": assertion failed"
	
	if movesize > 0 then
		// move rest of the memblock further to make room for the new var
		memCopy track\mem, offset, track\mem, offset + 8, movesize
	endif

	pokeFloat track\mem, offset		, point\bars 
	pokeFloat track\mem, offset + 4	, point\value 
	
	track\count = track\count + 1
	//temp = allocEnvpoint(envint)
	//memCopy temp, 0, track\mem, track\count * 8, 2*4
	//free temp
endFunction

function deleteEnvpoint(trackint, index)
	track.Synctrack = convertToType(trackint)
	If Not (index < track\count) Then makeError 837 + ": assertion failed"
	
	if track\count = 1 then
		return false
	endif
	
	offset = index * 8
	movesize = (MEMBlockSize(track\mem))-offset
	if movesize > 0 then
		memCopy track\mem, offset + 8, track\mem, offset, movesize
	endif
	
	resizeMEMBlock track\mem, MEMBlockSize(track\mem) - 8
	
	track\count = track\count - 1
endFunction

// returns void
function setEnvpoint(trackint, pointint, index)
	track.Synctrack = convertToType(trackint)
	If Not (index < track\count) Then makeError 857 + ": assertion failed"
	
	offset = index * 8
	point.Envpoint = convertToType(pointint)
	pokeFloat track\mem, offset		, point\bars
	pokeFloat track\mem, offset + 4	, point\value
endFunction

function setEnvpointValue(trackint, newbars#, newvalue#, index)
	track.Synctrack = convertToType(trackint)
	If Not (index < track\count) Then makeError 867 + ": assertion failed"
	offset = index * 8
	pokeFloat track\mem, offset		, newbars
	pokeFloat track\mem, offset + 4	, newvalue
endFunction

// clears the track, inserts one point at (0, 0)
function clearTrack(trackp)
	If Not (trackp <> -1) Then makeError 875 + ": assertion failed"
	track.Synctrack = convertToType(trackp)
	
	deleteMEMBlock track\mem
	
	track\mem = makeMEMBlock(4*2)
	pokeFloat track\mem, 0, 0.0
	pokeFloat track\mem, 4, 0.0
	
	track\count = 1
endFunction

// returns a string representation of the memory block contents
function memDumpFloat(memblock)
	out$ = ""
	
	i = 0
	while i < MEMBlockSize(memblock)
		if i mod 4 = 0 then
			out = out + str(peekFloat(memblock, i))
			out = out + ", "
		endif
		i + 4
	wend
	
	return out
endFunction

// #endif

//////////////////////////////////////////////
// the bare core components start here
//////////////////////////////////////////////

// returns a temporary memblock, remember to free it!
function allocEnvelopePoint(bars#, value#)
	tempblock = makeMEMBlock(8)
	pokeFloat tempblock, 0, bars
	pokeFloat tempblock, 4, value
	return tempblock
endFunction

// returns an envpoint in a temporary type instance, remember to delete it
function getEnvpoint(trackint, index)
	track.Synctrack = convertToType(trackint)
	If Not (index < track\count) Then makeError 920 + ": assertion failed"
	If Not (index >= 0) Then makeError 921 + ": assertion failed"
	
	point.Envpoint = new(Envpoint)
	point\bars	= peekFloat(track\mem, index*8)
	point\value = peekFloat(track\mem, index*8 + 4)
	point\index = index
	
	return convertToInteger(point)
endFunction


function firstPointAfter(trackint, startbar#)
	track.Synctrack = convertToType(trackint)
	
	// linear search
	for i=0 to track\count-1
		point.Envpoint = getEnvpoint(trackint, i)
		if point\bars >= startbar then
			return convertToInteger(point)
		endif
		
		delete point
	next i
	
	return -1
endFunction


function firstPointBefore(trackint, startbar#)
	track.Synctrack = convertToType(trackint)
	
	// linear search
	for i=track\count-1 to 0 step -1
		point.Envpoint = getEnvpoint(trackint, i)
		if point\bars <= startbar then
			return convertToInteger(point)
		endif
		
		delete point
	next i
	
	return -1
endFunction

// returns a pointer to a created Synctrack type instance
function createSyncTrack(name$)
	track.Synctrack = new (Synctrack)
	track\name = name
	track\count = 1
	//track\mem = allocEnvelopePoint(0.0, 0.0)
	track\mem = makeMEMBlock(4*2)
	pokeFloat track\mem, 0, 0.0
	pokeFloat track\mem, 4, 0.0
	
	return convertToInteger(track)
endFunction

function getEnvelopeValue(trackp, bars#)
	track.Synctrack = convertToType(trackp)
	
	firstpoint.EnvPoint = convertToType(getEnvPoint(trackp, 0))
	lastpoint.EnvPoint = convertToType(getEnvPoint(trackp, track\count-1))
	
	if bars < firstpoint\bars then
		return firstpoint\value
	endif
	
	if bars > lastpoint\bars then
		return lastpoint\value
	endif

	// is this redundant?
	if track\count = 1 then
		return firstpoint\value
	endif
	
	pointp = firstPointBefore(trackp, bars)
	
	if pointp <> -1 then
		point.EnvPoint = convertToType(pointp)

		if point\index = track\count-1 then
			return point\value
		endif
		
		nextPoint.EnvPoint = convertToType(getEnvPoint(trackp, point\index + 1))
		value_diff# = nextPoint\value - point\value
		time_diff# = nextPoint\bars - point\bars
		
		progress# = (bars - point\bars) / time_diff#
		return (point\value + ( nextPoint\value - point\value) *  progress)
	endif
	
	return 0.0
endFunction

function getTrackFilename(id)
	return "sync\testtrack"+id+".dat"
endFunction
