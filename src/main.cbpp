//#pragma dumb_debug
#pragma anticrap
//#define RELEASE

global MUSIC_PATH$
MUSIC_PATH = "assets/musa.mp3" // music path is at src/
global tempo#
tempo = 122.0
TRACK_AMOUNT = 19

const FONT_CONSOLE = 0
dim fonts(0)
fonts(FONT_CONSOLE) = loadFont("consolas", 12)

#ifdef RELEASE
include "inc/editor_release.cb"
#else
include "inc/editor_debug.cb"
#endif

include "inc/garbage.cb"	// compiled from effects/garbage.cbpp

demoInit:
	setWindow "peisik demo"
	gTrackNames = "cDist|cAng|cRot|cAlt"
	#ifndef RELEASE
		gResetFoobar = true
	#endif
return

scaleBuffer:
    for i=180 to 0 step -1
        copyBox 0, i,320,1,0, i*2,image(gBuffer),image(gBuffer)
        copyBox 0, i,320,1,0, i*2+1,image(gBuffer),image(gBuffer)
    next i
    for i=320 to 0 step -1
        copyBox i,0,1,360,i*2,0,image(gBuffer),image(gBuffer)
        copyBox i,0,1,360,i*2+1,0,image(gBuffer),image(gBuffer)
    next i
return

drawDemo:
	color 20, 20, 20
	box 0,0,640,480,1
    
    gosub atominEffu
   
return

//clamppi väreille niin että musta on 20
#define a_clampc(_cval) (max(20,min(255, _cval))) 
// fisheyee distance
#define a_dist(_px,_py,_pz) (sqrt(_px^2+_py^2+_pz^2))

atominEffu:
    //kamera pyörii jonkun jännän jutskan ympärillä. linejä. bucketointi lopuksi jos tarvii
    //y pienenee ylöspäin ja z kasvaa eteenpäin x kasvaa oikealle, kai
    color 200,0,0
    a_camerad#=track_values(0)*20//15+sin(bars*360)*10
    a_cameraa#=track_values(1)*700//bars*90
    a_camerar#=track_values(2)*700
    
    lock image(gBuffer)
    a_r=200
    for x=0 to 16
        for z=0 to 16
            px#=x-8
            py#=0.2
            pz#=z-8
            
            px2#=px
            py2#=py-0.5
            pz2#=pz
            
            gosub a_line_with_fog

            px#=x-8
            py#=-0.3
            pz#=z-8
            
            px2#=px
            py2#=py-0.5
            pz2#=pz
            gosub a_line_with_fog
            
            px#=x-8
            py#=-0.8
            pz#=z-8
            
            px2#=px
            py2#=py-0.5
            pz2#=pz
            gosub a_line_with_fog
            
        next z
    next x
    
    unlock
    
return

a_dot:
    gosub a_kamera
    pd#=a_dist(px,py,pz)
    if pz<0.1 then dot px/pd*180.0+160,py/pd*180.0+90
return

a_line:
    gosub a_kamera
    gosub a_kamera2
    pd#=a_dist(px,py,pz)
    pd2#=a_dist(px2,py2,pz2)
    if pz<0.1 and pz2<0.1 then line px/pd#*180.0+160,py/pd#*180.0+90,px2/pd2#*180.0+160,py2/pd2#*180.0+90
return

a_line_with_fog:
    gosub a_kamera
    gosub a_kamera2
    pd#=a_dist(px,py,pz)
    pd2#=a_dist(px2,py2,pz2)
    _d#=pd+pd2
    color a_clampc(a_r/_d*4-_d*2),a_clampc(a_g/_d*4-_d*2),a_clampc(a_b/_d*4-_d*2)
    if pz<0.1 and pz2<0.1 then line px/pd#*180.0+160,py/pd#*180.0+90,px2/pd2#*180.0+160,py2/pd2#*180.0+90
return

a_kamera:
    //rotate around origin and translate back
    px=px+cos(a_cameraa-90)*a_camerad
    pz=pz+sin(a_cameraa-90)*a_camerad
    a_a#=getAngle(0,0,px,pz)
    a_d#=distance(0,0,px,pz)
    px=cos(a_a+a_cameraa)*a_d
    pz=sin(a_a+a_cameraa)*a_d
    //rotate camera
    a_a#=getAngle(0,0,px,pz)
    a_d#=distance(0,0,px,pz)
    px=cos(a_a+a_camerar)*a_d
    pz=sin(a_a+a_camerar)*a_d
return

a_kamera2: //should be identical to a_kamera, except for variable names
    //rotate around origin and translate back
    px2=px2+cos(a_cameraa-90)*a_camerad
    pz2=pz2+sin(a_cameraa-90)*a_camerad
    a_a#=getAngle(0,0,px2,pz2)
    a_d#=distance(0,0,px2,pz2)
    px2=cos(a_a+a_cameraa)*a_d
    pz2=sin(a_a+a_cameraa)*a_d
    //rotate camera
    a_a#=getAngle(0,0,px2,pz2)
    a_d#=distance(0,0,px2,pz2)
    px2=cos(a_a+a_camerar)*a_d
    pz2=sin(a_a+a_camerar)*a_d
return

