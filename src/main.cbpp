//#pragma dumb_debug
#pragma anticrap
//#define RELEASE

#include "stdlib.cbpp"
#include "camera.cbpp"

#define drawToBuffer drawToImage gBuffer
//#define drawToBuffer drawToScreen
//clamppi väreille niin että musta on 20
#define a_clampc(_cval) (max(20,min(255, _cval))) 

// _RELEASE is a flag set by the precompiler
#ifdef _RELEASE
	#define RELEASE
#endif

#ifdef RELEASE
	gWindowMode = 1	
#endif

global MUSIC_PATH$
MUSIC_PATH = "assets/musa.mp3"
global tempo#
global gCurrentScene$
tempo = 100.0
TRACK_AMOUNT = 19

// SCENE LOADING
global gSceneAmount

scenelistpath$ = "sync/scenes.txt" 
gSceneAmount = countFileRows(scenelistpath)
assert(gSceneAmount > 0)
dim scene_names(gSceneAmount-1) as string
dim scene_start(gSceneAmount-1) as float
loadScenes(scenelistpath)

global imgGarbage	


#ifdef RELEASE
include "inc/editor_release.cb"
#else
include "inc/editor_debug.cb"
#endif

include "inc/objloader.cb"
include "inc/garbage.cb"	// compiled from effects/garbage.cbpp

demoInit:
	setWindow "peisik demo"

	gTrackNames =  "cDist|cAng|cRot|cAlt|cPitch|cRoll|cX|cY|cZ|fogDist|shipX|shipY|shipZ|gRoug|14|15|16|17|fade"
	#define TRACK_FADE 18
	#ifndef RELEASE
		gResetFoobar = true
	#endif
	
	shipobj = loadWavefrontObj("assets/obj/shup.obj")
	templeobj = loadWavefrontObj("assets/obj/temple.obj")
	
	imgSmallLogo = loadImage("assets/gfx/logo1.png")
	imgDemoLogo = loadImage("assets/gfx/demoname.png")
	imgFadeMask = makeImage(320, 240)
	
	trhProbTable = malloc(128*128*4)
	loadProbTable("assets/table.dat", trhProbTable)
	drawToWorld OFF, OFF, OFF
	imgGarbage = makeImage(320,360*4)

	consolefont =  loadFont("consolas", 12)
	setFont consolefont
	randomize 77
	makeGarbageImage(imgGarbage, trhProbTable, 0)
	randomize timer()
	free trhProbTable
	
	#define FEEDBACK_WIDTH 320
	#define FEEDBACK_HEIGHT 180
	
	gosub initFeedback
return

initFeedback:
		
	defaultMask 1, 255, 0, 255
	ping = makeImage(FEEDBACK_WIDTH,FEEDBACK_HEIGHT)
	pong = makeImage(FEEDBACK_WIDTH,FEEDBACK_HEIGHT)
	pang = makeImage(FEEDBACK_WIDTH,FEEDBACK_HEIGHT)
	pung = makeImage(FEEDBACK_WIDTH,FEEDBACK_HEIGHT)
	ptmp = makeImage(FEEDBACK_WIDTH,FEEDBACK_HEIGHT)
	defaultMask 1, 0,0,0
	grid = makeImage(FEEDBACK_WIDTH+1,FEEDBACK_HEIGHT+1)
	
	color 255, 0, 255
	drawToImage grid
	for i = 0 to 160
		line i*2, 0, i*2, 241
		if i<121 then line 0, i*2, 321, i*2
	next i
	drawToBuffer
	
	dim fpos(719,3)
	
	for i = 0 to 19
		for j = 0 to 35
			fpos(j+i*36,0) = 110+cos(j*10  )*(6.0*(i+.5))-6
			fpos(j+i*36,1) = 120+sin(j*10  )*(6.0*(i+.5))-6
			fpos(j+i*36,2) = 110+cos(j*10+2)*(6.0*(i+.62))-6
			fpos(j+i*36,3) = 120+sin(j*10+2)*(6.0*(i+.62))-6
		next j
	next i
	
	positionCamera FEEDBACK_WIDTH, -FEEDBACK_HEIGHT

return

scaleBuffer:
    for sb_i=180 to 0 step -1
        copyBox 0, sb_i,320,1,0, sb_i*2,image(gBuffer),image(gBuffer)
        copyBox 0, sb_i,320,1,0, sb_i*2+1,image(gBuffer),image(gBuffer)
    next sb_i
    for sb_i=320 to 0 step -1
        copyBox sb_i,0,1,360,sb_i*2,0,image(gBuffer),image(gBuffer)
        copyBox sb_i,0,1,360,sb_i*2+1,0,image(gBuffer),image(gBuffer)
    next sb_i
return

drawDemo:
	color 20, 20, 20
	box 0,0,640,480,1
    
	If gCurrentScene = "kiito" or gCurrentScene="demoname" then
		gosub kiitoEffu
	elseIf gCurrentScene = "jatkuu" then
		gosub aavikkoEffu
	elseIf gCurrentScene = "ufo" or gCurrentScene = "ufo2" then
		gosub sotkuEffu
	elseIf gCurrentScene = "mafia"
		gosub templeEffu
	else 
		gosub atominEffu
	endif
return

// colors the white parts of the given image to the given color
// result is saved to imgFadeMask
#define FADEIMAGE(_img, _r, _g, _b) maskImage imgFadeMask, 255, 255, 255 : maskImage _img, 255, 255, 255 : drawToImage imgFadeMask : color 0,0,0  : box 1,1,imageWidth(imgFadeMask)-1, imageHeight(imgFadeMask)-1  : color _r,_g,_b  : box 1,1,imageWidth(_img)-1, imageHeight(_img)-1 : drawImage _img, 1, 1 : drawToBuffer : maskImage _img, 0, 0, 0 : maskImage imgFadeMask, 0, 0, 0

aavikkoEffu:
	SET_CAMERA_VARS(a_)
    
    lock image(gBuffer)
    a_r=200

	gridscale#=2

	a_shipX = a_shipX + sin(bars*360.0*0.1)*3.0
	a_shipZ = a_shipZ * 3.0
	a_cZ = a_cZ*3.0

    a_gMovedX=a_cX/gridscale
    a_gMovedZ=(a_cZ/gridscale)

	#define gridsize 8

    for x=-gridsize-a_gMovedX to gridsize-a_gMovedX   
        a_gRough2#=min(1,(x*0.2)^2)*a_gRough
            for z=-gridsize-a_gMovedZ to gridsize-a_gMovedZ

            px#=(x+1)*gridscale
            pz#=z*gridscale
            py#=(sin(px*100)+sin(pz*100))*a_gRough2
            
            px2#=px-gridscale
            pz2#=pz
            py2#=(sin(px2*100)+sin(pz2*100))*a_gRough2

            gosub a_smart_line

            px#=x*gridscale
            pz#=(z+1)*gridscale
            py#=(sin(px*100)+sin(pz*100))*a_gRough2
            
            px2#=px
            pz2#=pz-gridscale
            py2#=(sin(px2*100)+sin(pz2*100))*a_gRough2

            gosub a_smart_line

        next z
    next x

	#undef gridsize

	RENDER_OBJECT(shipobj,a_,a_smart_line)
	
    
    unlock
return

templeEffu:
	SET_CAMERA_VARS(a_)
    
    lock image(gBuffer)
    a_r=200
	
	RENDER_OBJECT(templeobj,a_,a_smart_line)
    
    unlock
return

kiitoEffu:
	gosub atominEffu

	c = a_clampc(track_values(TRACK_FADE)*255)
	
	color cbWhite
	// fuckings to zerppa for "INVERTED-Y-AXIS-WHEN-DRAWING-text-to-image-SHIT!"
	text 5, -100, track_values(TRACK_FADE)
	
	if gCurrentScene = "demoname" then
		FADEIMAGE(imgDemoLogo, c, c, c)
		if c>20 then drawImage imgFadeMask, 160-imageWidth(imgDemoLogo)/2, 50
	else
		FADEIMAGE(imgSmallLogo, c, c, c)
		if c>20 then drawImage imgFadeMask, 15, 122
	endif
return

sotkuEffu:
	ypos# = -bars*100.0 + track_values(TRACK_FADE)*100.0
	
	// teksti näkyy vain hetken aikaa
	if gCurrentScene = "ufo" then 
		drawImage imgGarbage, 0, ypos mod imageHeight(imgGarbage)
		drawImage imgGarbage, 0, ypos mod imageHeight(imgGarbage) + imageHeight(imgGarbage)
	elseIf gCurrentScene = "ufo2" then
		gosub feedbackEffu
	endif
	
	
return

feedbackEffu:
	t = timer()
	ft2 = t
	
	lock image(pang)
	drawToImage pang
		color cbred
		SET_CAMERA_VARS(a_)
    
		a_r=200
	
		RENDER_OBJECT(shipobj,a_,a_smart_line)
	
	unlock
	drawToBuffer

	fy_ofs = -50
	
    if t<timer()
        k = k + 1
        If k>3 Then k = 0
        Select k
            Case 0
                For i = 0 To 179
                    copyBox fpos(i,0)+Rand(-1,1),fpos(i,1)+Rand(-1,1),12,12,fpos(i,2),fpos(i,3),Image(ping),Image(pong)
                Next i
                CopyBox 0,0,FEEDBACK_WIDTH,FEEDBACK_HEIGHT,0,0,Image(pung),Image(ptmp)
                DrawToImage ptmp
                DrawImage grid, -1, -1
                drawToImage pang
                DrawImage ptmp,0,0
                drawToBuffer
            Case 1
                For i = 180 To 359
                    CopyBox fpos(i,0)+Rand(-1,1),fpos(i,1)+Rand(-1,1),12,12,fpos(i,2),fpos(i,3),Image(ping),Image(pong)
                Next i
                CopyBox 0,0,FEEDBACK_WIDTH,FEEDBACK_HEIGHT,0,0,Image(pung),Image(ptmp)
                DrawToImage ptmp
                DrawImage grid, 0, 0
                DrawToImage pang
                DrawImage ptmp,0,0
                drawToBuffer
            Case 2
                For i = 360 To 539
                    CopyBox fpos(i,0)+Rand(-1,1),fpos(i,1)+Rand(-1,1),12,12,fpos(i,2),fpos(i,3),Image(ping),Image(pong)
                Next i
                CopyBox 0,0,FEEDBACK_WIDTH,FEEDBACK_HEIGHT,0,0,Image(pung),Image(ptmp)
                DrawToImage ptmp
                DrawImage grid, 0, -1
                DrawToImage pang
                DrawImage ptmp,0,0
                drawToBuffer
            Case 3
                For i = 540 To 179
                    CopyBox fpos(i,0)+rand(-1,1),fpos(i,1)+Rand(-1,1),12,12,fpos(i,2),fpos(i,3),Image(ping),Image(pong)
                Next i
                CopyBox 0,0,FEEDBACK_WIDTH,FEEDBACK_HEIGHT,0,0,Image(pung),Image(ptmp)
                DrawToImage ptmp
                DrawImage grid, -1, 0
                DrawToImage pang
                DrawImage ptmp,0,0
                drawToBuffer
                tmp = ping
                ping = pong
                pong = tmp
                CopyBox 0,0,FEEDBACK_WIDTH,FEEDBACK_HEIGHT,0,0,Image(pong),Image(pang)
                CopyBox 0,0,FEEDBACK_WIDTH,FEEDBACK_HEIGHT,0,0,Image(ping),Image(pung)
        endSelect
    endif
    //color max(0,127.5+127.5*Sin(bars*.015)-Max(0,bars-10000)-.01*Max(0,bars-10000)), Max(0,127.5+127.5*Sin(ft2*.02)-.01*Max(0,ft2-10000)), Max(0,127.5+127.5*Sin(ft2*.01)-.01*Max(0,ft2-10000))
	fphase# =sin(bars*360*0.5)
	//smokecolor = saturate(1.0+)*64+70
	fb = max(0.15, saturate(1.0/(fphase)))
	color saturate(fphase)*254,saturate(fphase)*200,saturate(fphase)*210
	drawToImage ping
    Circle 105+10*Sin(ft*.1), 115+10*cos(ft*.12), 10
    drawToBuffer
    DrawImage pang, 0, 0
return 


// fisheyee distance
#define a_dist(_px,_py,_pz) (sqrt((_px)^2+(_py)^2+(_pz)^2))

atominEffu:
    //kamera pyörii jonkun jännän jutskan ympärillä. linejä. bucketointi lopuksi jos tarvii
    //y pienenee ylöspäin ja z kasvaa eteenpäin x kasvaa oikealle, kai
    color 200,0,0
	/*
    a_cDist#=-track_values(0)*20//15+sin(bars*360)*10
    a_cAng#=track_values(1)*700//bars*90
    a_cRot#=track_values(2)*700
    a_cAlt#=track_values(3)*10-5
    a_cPitch#=track_values(4)*700
    a_cRoll#=track_values(5)*700
    a_cX#=track_values(6)*50
    a_cY#=track_values(7)*50
    a_cZ#=track_values(8)*-50
    a_cFog#=track_values(9)+0.1
    a_shipX#=track_values(10)*50
    a_shipY#=track_values(11)*50
    a_shipZ#=track_values(12)*50
    a_gRough#=track_values(13)*0.5
	*/
	
	SET_CAMERA_VARS(a_)
    
    lock image(gBuffer)
    a_r=200

	gridscale#=2

    a_gMovedX=a_cX/gridscale
    a_gMovedZ=a_cZ/gridscale

    for x=-8-a_gMovedX to 8-a_gMovedX   
        a_gRough2#=min(1,(x*0.2)^2)*a_gRough
            for z=-8-a_gMovedZ to 8-a_gMovedZ

            px#=(x+1)*gridscale
            pz#=z*gridscale
            py#=(sin(px*100)+sin(pz*100))*a_gRough2
            
            px2#=px-gridscale
            pz2#=pz
            py2#=(sin(px2*100)+sin(pz2*100))*a_gRough2

            gosub a_smart_line

            px#=x*gridscale
            pz#=(z+1)*gridscale
            py#=(sin(px*100)+sin(pz*100))*a_gRough2
            
            px2#=px
            pz2#=pz-gridscale
            py2#=(sin(px2*100)+sin(pz2*100))*a_gRough2

            gosub a_smart_line

        next z
    next x
	

    //test rendering an object
    a_mx=peekInt(shipobj,0)
    a_my=peekInt(shipobj,4)
    a_mz=peekInt(shipobj,8)
    a_size=MEMBlockSize(a_mx)
    
    a_cX+a_shipX
    a_cY+a_shipY
    a_cZ+a_shipZ

    for i=0 to a_size-8 step 8
		
        px#=peekFloat(a_mx,i)
        py#=peekFloat(a_my,i)
        pz#=peekFloat(a_mz,i)
        i2=i+4
        px2#=peekFloat(a_mx,i2)
        py2#=peekFloat(a_my,i2)
        pz2#=peekFloat(a_mz,i2)
        
        //gosub a_line_with_fog
        gosub a_smart_line
    next i
    
    unlock
return

a_dot:
    gosub a_kamera
    pd#=a_dist(px,py,pz)
    if pz<0.2 then dot px/pd*180.0+160,py/pd*180.0+90
return

a_line:
    gosub a_kamera
    gosub a_kamera2
    pd#=a_dist(px,py,pz)
    pd2#=a_dist(px2,py2,pz2)
    if pz<0.2 and pz2<0.2 then line px/pd#*180.0+160,py/pd#*180.0+90,px2/pd2#*180.0+160,py2/pd2#*180.0+90
return

a_line_with_fog:
    gosub a_kamera
    gosub a_kamera2
    pd#=a_dist(px,py,pz)
    pd2#=a_dist(px2,py2,pz2)
    _d#=(pd+pd2)*2*a_cFog
    color a_clampc(a_r/_d*2-_d),a_clampc(a_g/_d*2-_d),a_clampc(a_b/_d*2-_d)
    if pz<0.2 and pz2<0.2 then line px/pd#*180.0+160,py/pd#*180.0+90,px2/pd2#*180.0+160,py2/pd2#*180.0+90
return

_s_a_line_with_fog: //takes _-prefixed input-variables instead
    gosub _s_a_kamera
    gosub _s_a_kamera2
    pd#=a_dist(px,py,pz)
    pd2#=a_dist(px2,py2,pz2)
    _d#=(pd+pd2)*2*a_cFog
    color a_clampc(a_r/_d*2-_d),a_clampc(a_g/_d*2-_d),a_clampc(a_b/_d*2-_d)
    if pz<0.2 and pz2<0.2 then line px/pd#*180.0+160,py/pd#*180.0+90,px2/pd2#*180.0+160,py2/pd2#*180.0+90
return

a_smart_line:
    _px#=px//do this just to avoid another copy of camera function
    _py#=py
    _pz#=pz
    _s_d=a_dist(px-px2,py-py2,pz-pz2)*6
    px=(px+px2)/2
    py=(py+py2)/2
    pz=(pz+pz2)/2
    gosub a_kamera
    _s_d=_s_d/(a_dist(px,py,pz)^2*0.2+0.5)+1

    if _s_d>1 then
        _dx#=(px2-_px)/_s_d
        _dy#=(py2-_py)/_s_d
        _dz#=(pz2-_pz)/_s_d
        _s_px#=_px
        _s_py#=_py
        _s_pz#=_pz
        for _s_i=1 to _s_d-1
            _px2#=_s_px+_dx*_s_i
            _py2#=_s_py+_dy*_s_i
            _pz2#=_s_pz+_dz*_s_i
            _s_i2=_s_i+1
            gosub _s_a_line_with_fog
            _px=_s_px+_dx*_s_i2
            _py=_s_py+_dy*_s_i2
            _pz=_s_pz+_dz*_s_i2
            gosub _s_a_line_with_fog
        next _s_i
    else
        px=_px
        py=_py
        pz=_pz
        gosub a_line_with_fog
    endif
return


a_kamera:
    //rotate around origin and translate back
    px=px+cos(a_cAng-90)*a_cDist+a_cX
    pz=pz-sin(a_cAng-90)*a_cDist+a_cZ
    py=py+a_cAlt+a_cY
    a_a#=-getAngle(0,0,px,pz)
    a_d#=-distance(0,0,px,pz)
    px=cos(a_a+a_cAng)*a_d
    pz=-sin(a_a+a_cAng)*a_d
    //rotate camera
    a_a#=getAngle(0,0,px,pz)
    a_d#=distance(0,0,px,pz)
    px=cos(a_a+a_cRot)*a_d
    pz=-sin(a_a+a_cRot)*a_d
    //pitch
    a_a#=getAngle(0,0,pz,py)
    a_d#=distance(0,0,pz,py)
    pz=cos(a_a+a_cPitch)*a_d
    py=-sin(a_a+a_cPitch)*a_d
    //roll
    a_a#=getAngle(0,0,px,py)
    a_d#=distance(0,0,px,py)
    px=cos(a_a+a_cRoll)*a_d
    py=-sin(a_a+a_cRoll)*a_d
return


a_kamera2: //should be identical to a_kamera, except for variable names
    //rotate around origin and translate back
    px2=px2+cos(a_cAng-90)*a_cDist+a_cX
    pz2=pz2-sin(a_cAng-90)*a_cDist+a_cZ
    py2=py2+a_cAlt+a_cY
    a_a#=-getAngle(0,0,px2,pz2)
    a_d#=-distance(0,0,px2,pz2)
    px2=cos(a_a+a_cAng)*a_d
    pz2=-sin(a_a+a_cAng)*a_d
    //rotate camera
    a_a#=getAngle(0,0,px2,pz2)
    a_d#=distance(0,0,px2,pz2)
    px2=cos(a_a+a_cRot)*a_d
    pz2=-sin(a_a+a_cRot)*a_d
    //pitch
    a_a#=getAngle(0,0,pz2,py2)
    a_d#=distance(0,0,pz2,py2)
    pz2=cos(a_a+a_cPitch)*a_d
    py2=-sin(a_a+a_cPitch)*a_d
    //roll
    a_a#=getAngle(0,0,px2,py2)
    a_d#=distance(0,0,px2,py2)
    px2=cos(a_a+a_cRoll)*a_d
    py2=-sin(a_a+a_cRoll)*a_d
return

//takes _-prefixed input-variables instead
_s_a_kamera:
    //rotate around origin and translate back
    px=_px+cos(a_cAng-90)*a_cDist+a_cX
    pz=_pz-sin(a_cAng-90)*a_cDist+a_cZ
    py=_py+a_cAlt+a_cY
    a_a#=-getAngle(0,0,px,pz)
    a_d#=-distance(0,0,px,pz)
    px=cos(a_a+a_cAng)*a_d
    pz=-sin(a_a+a_cAng)*a_d
    //rotate camera
    a_a#=getAngle(0,0,px,pz)
    a_d#=distance(0,0,px,pz)
    px=cos(a_a+a_cRot)*a_d
    pz=-sin(a_a+a_cRot)*a_d
    //pitch
    a_a#=getAngle(0,0,pz,py)
    a_d#=distance(0,0,pz,py)
    pz=cos(a_a+a_cPitch)*a_d
    py=-sin(a_a+a_cPitch)*a_d
    //roll
    a_a#=getAngle(0,0,px,py)
    a_d#=distance(0,0,px,py)
    px=cos(a_a+a_cRoll)*a_d
    py=-sin(a_a+a_cRoll)*a_d
return

//takes _-prefixed input-variables instead
_s_a_kamera2: //should be identical to a_kamera, except for variable names
    //rotate around origin and translate back
    px2=_px2+cos(a_cAng-90)*a_cDist+a_cX
    pz2=_pz2-sin(a_cAng-90)*a_cDist+a_cZ
    py2=_py2+a_cAlt+a_cY
    a_a#=-getAngle(0,0,px2,pz2)
    a_d#=-distance(0,0,px2,pz2)
    px2=cos(a_a+a_cAng)*a_d
    pz2=-sin(a_a+a_cAng)*a_d
    //rotate camera
    a_a#=getAngle(0,0,px2,pz2)
    a_d#=distance(0,0,px2,pz2)
    px2=cos(a_a+a_cRot)*a_d
    pz2=-sin(a_a+a_cRot)*a_d
    //pitch
    a_a#=getAngle(0,0,pz2,py2)
    a_d#=distance(0,0,pz2,py2)
    pz2=cos(a_a+a_cPitch)*a_d
    py2=-sin(a_a+a_cPitch)*a_d
    //roll
    a_a#=getAngle(0,0,px2,py2)
    a_d#=distance(0,0,px2,py2)
    px2=cos(a_a+a_cRoll)*a_d
    py2=-sin(a_a+a_cRoll)*a_d
return




