//#pragma dumb_debug
#pragma anticrap
//#define RELEASE

global MUSIC_PATH$
MUSIC_PATH = "assets/musa.mp3" // music path is at src/
global tempo#
tempo = 130.0
TRACK_AMOUNT = 19

const FONT_CONSOLE = 0
dim fonts(0)
fonts(FONT_CONSOLE) = loadFont("consolas", 12)

#ifdef RELEASE
include "inc/editor_release.cb"
#else
include "inc/editor_debug.cb"
#endif

include "inc/garbage.cb"	// compiled from effects/garbage.cbpp

demoInit:
	setWindow "peisik demo"
	gTrackNames = "cDist|cAng|cRot"
	#ifndef RELEASE
		gResetFoobar = true
	#endif
    
return

scaleBuffer:
    for i=180 to 0 step -1
        copyBox 0, i,320,1,0, i*2,image(gBuffer),image(gBuffer)
        copyBox 0, i,320,1,0, i*2+1,image(gBuffer),image(gBuffer)
    next i
    for i=320 to 0 step -1
        copyBox i,0,1,360,i*2,0,image(gBuffer),image(gBuffer)
        copyBox i,0,1,360,i*2+1,0,image(gBuffer),image(gBuffer)
    next i
return

drawDemo:
	color 20, 20, 20
	box 0,0,640,480,1
    
    gosub atominEffu
   
return


atominEffu:
    //kamera pyörii jonkun jännän jutskan ympärillä. linejä. bucketointi lopuksi jos tarvii
    color 200,0,0
    a_camerad#=track_values(0)*20//15+sin(bars*360)*10
    a_cameraa#=track_values(1)*700//bars*90
    a_camerar#=track_values(2)*700
    
    lock image(gBuffer)
    
    for x=0 to 16
        for z=0 to 16
            px#=x-8
            py#=-1
            pz#=z-8
            
            px2#=px
            py2#=py+1.2
            pz2#=pz
            
            gosub a_line

            px#=x-8
            py#=-1
            pz#=z-8
            
            px2#=px
            py2#=py-1
            pz2#=pz
            gosub a_line
            //gosub a_dot
            
        next z
    next x
    
    unlock
    
return

a_dot:

    gosub a_kamera
    if pz<0.1 then dot px/pz*180.0+160,py/pz*180.0+90

return

a_line:
    gosub a_kamera
    gosub a_dist
    gosub a_kamera2
    gosub a_dist2
    if pz<0.1 and pz2<0.1 then line px/pd#*180.0+160,py/pd#*180.0+90,px2/pd2#*180.0+160,py2/pd2#*180.0+90
return

//kalansilmädistancet
a_dist:
    pd#=sqrt(px^2+py^2+pz^2)
return

a_dist2:
    pd2#=sqrt(px2^2+py2^2+pz2^2)
return


a_kamera:
    //rotate around origin and translate back
    px=px+cos(a_cameraa-90)*a_camerad
    pz=pz+sin(a_cameraa-90)*a_camerad
    a_a#=getAngle(0,0,px,pz)
    a_d#=distance(0,0,px,pz)
    px=cos(a_a+a_cameraa)*a_d
    pz=sin(a_a+a_cameraa)*a_d
    //rotate camera
    a_a#=getAngle(0,0,px,pz)
    a_d#=distance(0,0,px,pz)
    px=cos(a_a+a_camerar)*a_d
    pz=sin(a_a+a_camerar)*a_d
return

a_kamera2: //should be identical to a_kamera, except for variable names
    //rotate around origin and translate back
    px2=px2+cos(a_cameraa-90)*a_camerad
    pz2=pz2+sin(a_cameraa-90)*a_camerad
    a_a#=getAngle(0,0,px2,pz2)
    a_d#=distance(0,0,px2,pz2)
    px2=cos(a_a+a_cameraa)*a_d
    pz2=sin(a_a+a_cameraa)*a_d
    //rotate camera
    a_a#=getAngle(0,0,px2,pz2)
    a_d#=distance(0,0,px2,pz2)
    px2=cos(a_a+a_camerar)*a_d
    pz2=sin(a_a+a_camerar)*a_d
return

