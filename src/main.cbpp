//#pragma dumb_debug
#pragma anticrap
//#define RELEASE

global MUSIC_PATH$
MUSIC_PATH = "zetaforce.mp3" // music path root is currently at ../seek
global tempo#
tempo = 130.0

#ifdef RELEASE
include "inc/editor_release.cb"
#else
include "inc/editor_debug.cb"
#endif

demoInit:
	setWindow "peisik demo"
return

drawDemo:
	color 255, 0, 0
	box 0,0,640,480,1
	
	c = 200 * track_values(2)
	color c,c,c
	x_pos = 100 + track_values(0) * 300
	y_pos = 100 + track_values(1) * 200
	//box x_pos, y_pos, 100, 100, true
    
    gosub atominEffu
   
return


atominEffu:
    //kamera pyörii jonkun jännän jutskan ympärillä. linejä. bucketointi lopuksi jos tarvii
    
    a_camerad#=track_values(3)*20//15+sin(bars*360)*10
    a_cameraa#=track_values(4)*700//bars*90
    a_camerar#=track_values(5)*700
    
    for x=0 to 16
        for z=0 to 16
            px#=x-8
            py#=-2
            pz#=z-8
            
            px2#=px
            py2#=py+2
            pz2#=pz
            
            gosub a_line
            //gosub a_dot
            
            
            //print x+z
        next z
    next x
    
    
return

a_dot:

    gosub a_kamera
    if pz<0.1 then dot px/pz*40.0+140,py/pz*40.0+90

return

a_line:
    gosub a_kamera
    gosub a_dist
    gosub a_kamera2
    gosub a_dist2
    if pz<0.1 and pz2<0.1 then line px/pd#*80.0+140,py/pd#*80.0+90,px2/pd2#*80.0+140,py2/pd2#*80.0+90
return

//kalansilmädistancet
a_dist:
    pd#=sqrt(px^2+py^2+pz^2)
return

a_dist2:
    pd2#=sqrt(px2^2+py2^2+pz2^2)
return


a_kamera:
    //rotate around origin and translate back
    px=px+cos(a_cameraa-90)*a_camerad
    pz=pz+sin(a_cameraa-90)*a_camerad
    a_a#=getAngle(0,0,px,pz)
    a_d#=distance(0,0,px,pz)
    px=cos(a_a+a_cameraa)*a_d
    pz=sin(a_a+a_cameraa)*a_d
    //rotate camera
    a_a#=getAngle(0,0,px,pz)
    a_d#=distance(0,0,px,pz)
    px=cos(a_a+a_camerar)*a_d
    pz=sin(a_a+a_camerar)*a_d
return

a_kamera2: //should be identical to a_kamera, except for variable names
    //rotate around origin and translate back
    px2=px2+cos(a_cameraa-90)*a_camerad
    pz2=pz2+sin(a_cameraa-90)*a_camerad
    a_a#=getAngle(0,0,px2,pz2)
    a_d#=distance(0,0,px2,pz2)
    px2=cos(a_a+a_cameraa)*a_d
    pz2=sin(a_a+a_cameraa)*a_d
    //rotate camera
    a_a#=getAngle(0,0,px2,pz2)
    a_d#=distance(0,0,px2,pz2)
    px2=cos(a_a+a_camerar)*a_d
    pz2=sin(a_a+a_camerar)*a_d
return



