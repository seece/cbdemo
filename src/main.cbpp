//#pragma dumb_debug
#pragma anticrap
//#define RELEASE

#define assert(statement) If not (statement) Then makeError __LINE__ + ": assertion failed"
#define malloc(size) makeMEMBlock(size)
#define free deleteMEMBlock

// _RELEASE is a flag set by the precompiler
#ifdef _RELEASE
	#define RELEASE
#endif

#ifdef RELEASE
	gWindowMode = 1	
#endif

global MUSIC_PATH$
MUSIC_PATH = "assets/musa.mp3"
global tempo#
tempo = 122.0
TRACK_AMOUNT = 19

// SCENE LOADING
global gSceneAmount

scenelistpath$ = "sync/scenes.txt" 
gSceneAmount = countFileRows(scenelistpath)
assert(gSceneAmount > 0)
dim scene_names(gSceneAmount-1) as string
dim scene_start(gSceneAmount-1) as float
loadScenes(scenelistpath)

global imgGarbage


#ifdef RELEASE
include "inc/editor_release.cb"
#else
include "inc/editor_debug.cb"
#endif

include "inc/objloader.cb"
include "inc/garbage.cb"	// compiled from effects/garbage.cbpp

demoInit:
	setWindow "peisik demo"
	gTrackNames =  "cDist|cAng|cRot|cAlt|cPitch|cRoll|cX|cY|cZ|fogDist"
	#ifndef RELEASE
		gResetFoobar = true
	#endif
	
	testobj = loadWavefrontObj("assets/obj/testscene.obj")
	
	trhProbTable = malloc(128*128*4)
	loadProbTable("assets/table.dat", trhProbTable)
	drawToWorld OFF, OFF, OFF
	imgGarbage = makeImage(320,360*4)

	consolefont =  loadFont("consolas", 12)
	setFont consolefont
	randomize 77
	makeGarbageImage(imgGarbage, trhProbTable, 0)
	randomize timer()
	free trhProbTable
return

scaleBuffer:
    for sb_i=180 to 0 step -1
        copyBox 0, sb_i,320,1,0, sb_i*2,image(gBuffer),image(gBuffer)
        copyBox 0, sb_i,320,1,0, sb_i*2+1,image(gBuffer),image(gBuffer)
    next sb_i
    for sb_i=320 to 0 step -1
        copyBox sb_i,0,1,360,sb_i*2,0,image(gBuffer),image(gBuffer)
        copyBox sb_i,0,1,360,sb_i*2+1,0,image(gBuffer),image(gBuffer)
    next sb_i
return

drawDemo:
	color 20, 20, 20
	box 0,0,640,480,1
    
	if gCurrentScene = "move_out" then
		gosub toinenEffu
	else 
		gosub atominEffu
	endif
return

toinenEffu:
	ypos# = -bars*100.0
	drawImage imgGarbage, 0, ypos mod imageHeight(imgGarbage)
	drawImage imgGarbage, 0, ypos mod imageHeight(imgGarbage) + imageHeight(imgGarbage)
return

//clamppi väreille niin että musta on 20
#define a_clampc(_cval) (max(20,min(255, _cval))) 
// fisheyee distance
#define a_dist(_px,_py,_pz) (sqrt((_px)^2+(_py)^2+(_pz)^2))

atominEffu:
    //kamera pyörii jonkun jännän jutskan ympärillä. linejä. bucketointi lopuksi jos tarvii
    //y pienenee ylöspäin ja z kasvaa eteenpäin x kasvaa oikealle, kai
    color 200,0,0
    a_cDist#=-track_values(0)*20//15+sin(bars*360)*10
    a_cAng#=track_values(1)*700//bars*90
    a_cRot#=track_values(2)*700
    a_cAlt#=track_values(3)*10
    a_cPitch#=track_values(4)*700
    a_cRoll#=track_values(5)*700
    a_cX#=track_values(6)*100
    a_cY#=track_values(7)*100
    a_cZ#=track_values(8)*100
    a_cFog#=track_values(9)+0.1
    
    lock image(gBuffer)
    a_r=200

    for x=0 to 16
        for z=0 to 16
            px#=x-8
            py#=0.2
            pz#=z-8
            
            px2#=px
            py2#=py-1.5
            pz2#=pz

            gosub a_smart_line
        next z
    next x
    
    //test rendering an object
    a_mx=peekInt(testobj,0)
    a_my=peekInt(testobj,4)
    a_mz=peekInt(testobj,8)
    a_size=MEMBlockSize(a_mx)
    

    for i=0 to a_size-8 step 8
        px#=peekFloat(a_mx,i)+1.3
        py#=peekFloat(a_my,i)-2
        pz#=peekFloat(a_mz,i)-1.3
        i2=i+4
        px2#=peekFloat(a_mx,i2)+1.3
        py2#=peekFloat(a_my,i2)-2
        pz2#=peekFloat(a_mz,i2)-1.3
        
        //gosub a_line_with_fog
        gosub a_smart_line
    next i
    
    unlock
return

a_dot:
    gosub a_kamera
    pd#=a_dist(px,py,pz)
    if pz<0.2 then dot px/pd*180.0+160,py/pd*180.0+90
return

a_line:
    gosub a_kamera
    gosub a_kamera2
    pd#=a_dist(px,py,pz)
    pd2#=a_dist(px2,py2,pz2)
    if pz<0.2 and pz2<0.2 then line px/pd#*180.0+160,py/pd#*180.0+90,px2/pd2#*180.0+160,py2/pd2#*180.0+90
return

a_line_with_fog:
    gosub a_kamera
    gosub a_kamera2
    pd#=a_dist(px,py,pz)
    pd2#=a_dist(px2,py2,pz2)
    _d#=(pd+pd2)*2*a_cFog
    color a_clampc(a_r/_d*2-_d),a_clampc(a_g/_d*2-_d),a_clampc(a_b/_d*2-_d)
    if pz<0.2 and pz2<0.2 then line px/pd#*180.0+160,py/pd#*180.0+90,px2/pd2#*180.0+160,py2/pd2#*180.0+90
return

_s_a_line_with_fog: //takes _-prefixed input-variables instead
    gosub _s_a_kamera
    gosub _s_a_kamera2
    pd#=a_dist(px,py,pz)
    pd2#=a_dist(px2,py2,pz2)
    _d#=(pd+pd2)*2*a_cFog
    color a_clampc(a_r/_d*2-_d),a_clampc(a_g/_d*2-_d),a_clampc(a_b/_d*2-_d)
    if pz<0.2 and pz2<0.2 then line px/pd#*180.0+160,py/pd#*180.0+90,px2/pd2#*180.0+160,py2/pd2#*180.0+90
return

a_smart_line:
    _px#=px//do this just to avoid another copy of camera function
    _py#=py
    _pz#=pz
    _s_d=a_dist(px-px2,py-py2,pz-pz2)*6
    px=(px+px2)/2
    py=(py+py2)/2
    pz=(pz+pz2)/2
    gosub a_kamera
    _s_d=_s_d/(a_dist(px,py,pz)^2*0.2+0.5)+1

    if _s_d>1 then
        _dx#=(px2-_px)/_s_d
        _dy#=(py2-_py)/_s_d
        _dz#=(pz2-_pz)/_s_d
        _s_px#=_px
        _s_py#=_py
        _s_pz#=_pz
        for _s_i=1 to _s_d-1
            _px2#=_s_px+_dx*_s_i
            _py2#=_s_py+_dy*_s_i
            _pz2#=_s_pz+_dz*_s_i
            _s_i2=_s_i+1
            gosub _s_a_line_with_fog
            _px=_s_px+_dx*_s_i2
            _py=_s_py+_dy*_s_i2
            _pz=_s_pz+_dz*_s_i2
            gosub _s_a_line_with_fog
        next _s_i
    else
        px=_px
        py=_py
        pz=_pz
        gosub a_line_with_fog
    endif
return


a_kamera:
    //rotate around origin and translate back
    px=px+cos(a_cAng-90)*a_cDist+a_cX
    pz=pz-sin(a_cAng-90)*a_cDist+a_cZ
    py=py+a_cAlt+a_cY
    a_a#=-getAngle(0,0,px,pz)
    a_d#=-distance(0,0,px,pz)
    px=cos(a_a+a_cAng)*a_d
    pz=-sin(a_a+a_cAng)*a_d
    //rotate camera
    a_a#=getAngle(0,0,px,pz)
    a_d#=distance(0,0,px,pz)
    px=cos(a_a+a_cRot)*a_d
    pz=-sin(a_a+a_cRot)*a_d
    //pitch
    a_a#=getAngle(0,0,pz,py)
    a_d#=distance(0,0,pz,py)
    pz=cos(a_a+a_cPitch)*a_d
    py=-sin(a_a+a_cPitch)*a_d
    //roll
    a_a#=getAngle(0,0,px,py)
    a_d#=distance(0,0,px,py)
    px=cos(a_a+a_cRoll)*a_d
    py=-sin(a_a+a_cRoll)*a_d
return


a_kamera2: //should be identical to a_kamera, except for variable names
    //rotate around origin and translate back
    px2=px2+cos(a_cAng-90)*a_cDist+a_cX
    pz2=pz2-sin(a_cAng-90)*a_cDist+a_cZ
    py2=py2+a_cAlt+a_cY
    a_a#=-getAngle(0,0,px2,pz2)
    a_d#=-distance(0,0,px2,pz2)
    px2=cos(a_a+a_cAng)*a_d
    pz2=-sin(a_a+a_cAng)*a_d
    //rotate camera
    a_a#=getAngle(0,0,px2,pz2)
    a_d#=distance(0,0,px2,pz2)
    px2=cos(a_a+a_cRot)*a_d
    pz2=-sin(a_a+a_cRot)*a_d
    //pitch
    a_a#=getAngle(0,0,pz2,py2)
    a_d#=distance(0,0,pz2,py2)
    pz2=cos(a_a+a_cPitch)*a_d
    py2=-sin(a_a+a_cPitch)*a_d
    //roll
    a_a#=getAngle(0,0,px2,py2)
    a_d#=distance(0,0,px2,py2)
    px2=cos(a_a+a_cRoll)*a_d
    py2=-sin(a_a+a_cRoll)*a_d
return

//takes _-prefixed input-variables instead
_s_a_kamera:
    //rotate around origin and translate back
    px=_px+cos(a_cAng-90)*a_cDist+a_cX
    pz=_pz-sin(a_cAng-90)*a_cDist+a_cZ
    py=_py+a_cAlt+a_cY
    a_a#=-getAngle(0,0,px,pz)
    a_d#=-distance(0,0,px,pz)
    px=cos(a_a+a_cAng)*a_d
    pz=-sin(a_a+a_cAng)*a_d
    //rotate camera
    a_a#=getAngle(0,0,px,pz)
    a_d#=distance(0,0,px,pz)
    px=cos(a_a+a_cRot)*a_d
    pz=-sin(a_a+a_cRot)*a_d
    //pitch
    a_a#=getAngle(0,0,pz,py)
    a_d#=distance(0,0,pz,py)
    pz=cos(a_a+a_cPitch)*a_d
    py=-sin(a_a+a_cPitch)*a_d
    //roll
    a_a#=getAngle(0,0,px,py)
    a_d#=distance(0,0,px,py)
    px=cos(a_a+a_cRoll)*a_d
    py=-sin(a_a+a_cRoll)*a_d
return

//takes _-prefixed input-variables instead
_s_a_kamera2: //should be identical to a_kamera, except for variable names
    //rotate around origin and translate back
    px2=_px2+cos(a_cAng-90)*a_cDist+a_cX
    pz2=_pz2-sin(a_cAng-90)*a_cDist+a_cZ
    py2=_py2+a_cAlt+a_cY
    a_a#=-getAngle(0,0,px2,pz2)
    a_d#=-distance(0,0,px2,pz2)
    px2=cos(a_a+a_cAng)*a_d
    pz2=-sin(a_a+a_cAng)*a_d
    //rotate camera
    a_a#=getAngle(0,0,px2,pz2)
    a_d#=distance(0,0,px2,pz2)
    px2=cos(a_a+a_cRot)*a_d
    pz2=-sin(a_a+a_cRot)*a_d
    //pitch
    a_a#=getAngle(0,0,pz2,py2)
    a_d#=distance(0,0,pz2,py2)
    pz2=cos(a_a+a_cPitch)*a_d
    py2=-sin(a_a+a_cPitch)*a_d
    //roll
    a_a#=getAngle(0,0,px2,py2)
    a_d#=distance(0,0,px2,py2)
    px2=cos(a_a+a_cRoll)*a_d
    py2=-sin(a_a+a_cRoll)*a_d
return




