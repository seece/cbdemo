//#pragma dumb_debug
// #pragma anticrap
//#define RELEASE

// #include "stdlib.cbpp"
// #define drawToBuffer drawToImage gBuffer
//#define drawToBuffer drawToScreen
//clamppi väreille niin että musta on 20
// #define a_clampc(_cval) (max(20,min(255, _cval))) 

// _RELEASE is a flag set by the precompiler
// #ifdef _RELEASE
// 	#define RELEASE
// #endif

// #ifdef RELEASE
	gWindowMode = 1	
// #endif

global MUSIC_PATH$
MUSIC_PATH = "assets/musa.mp3"
global tempo#
global gCurrentScene$
tempo = 100.0
TRACK_AMOUNT = 19

// SCENE LOADING
global gSceneAmount

scenelistpath$ = "sync/scenes.txt" 
gSceneAmount = countFileRows(scenelistpath)
If Not (gSceneAmount > 0) Then makeError 32 + ": assertion failed"
dim scene_names(gSceneAmount-1) as string
dim scene_start(gSceneAmount-1) as float
loadScenes(scenelistpath)

global imgGarbage	


// #ifdef RELEASE
include "inc/editor_release.cb"
// #else



include "inc/objloader.cb"
include "inc/garbage.cb"	// compiled from effects/garbage\cbpp

demoInit:
	setWindow "peisik demo"

	gTrackNames =  "cDist|cAng|cRot|cAlt|cPitch|cRoll|cX|cY|cZ|fogDist|shipX|shipY|shipZ|gRoug|14|15|16|17|fade"
// 	#define TRACK_FADE 18
// 	#ifndef RELEASE


	
	testobj = loadWavefrontObj("assets/obj/shup.obj")
	
	imgSmallLogo = loadImage("assets/gfx/logo1.png")
	imgDemoLogo = loadImage("assets/gfx/demoname.png")
	imgFadeMask = makeImage(320, 240)
	
	trhProbTable = makeMEMBlock(128*128*4)
	loadProbTable("assets/table.dat", trhProbTable)
	drawToWorld OFF, OFF, OFF
	imgGarbage = makeImage(320,360*4)

	consolefont =  loadFont("consolas", 12)
	setFont consolefont
	randomize 77
	makeGarbageImage(imgGarbage, trhProbTable, 0)
	randomize timer()
	deleteMEMBlock trhProbTable
return

scaleBuffer:
    for sb_i=180 to 0 step -1
        copyBox 0, sb_i,320,1,0, sb_i*2,image(gBuffer),image(gBuffer)
        copyBox 0, sb_i,320,1,0, sb_i*2+1,image(gBuffer),image(gBuffer)
    next sb_i
    for sb_i=320 to 0 step -1
        copyBox sb_i,0,1,360,sb_i*2,0,image(gBuffer),image(gBuffer)
        copyBox sb_i,0,1,360,sb_i*2+1,0,image(gBuffer),image(gBuffer)
    next sb_i
return

drawDemo:
	color 20, 20, 20
	box 0,0,640,480,1
    
	if gCurrentScene = "move_out" then
		gosub toinenEffu
	elseIf gCurrentScene = "kiito" or gCurrentScene="invert" then
		gosub kiitoEffu
	else 
		gosub atominEffu
	endif
return

// colors the white parts of the given image to the given color
// result is saved to imgFadeMask
// #define FADEIMAGE(_img, _r, _g, _b) maskImage imgFadeMask, 255, 255, 255 : maskImage _img, 255, 255, 255 : drawToImage imgFadeMask : color 0,0,0  : box 1,1,imageWidth(imgFadeMask)-1, imageHeight(imgFadeMask)-1  : color _r,_g,_b  : box 1,1,imageWidth(_img)-1, imageHeight(_img)-1 : drawImage _img, 1, 1 : drawToBuffer : maskImage _img, 0, 0, 0 : maskImage imgFadeMask, 0, 0, 0

kiitoEffu:
	gosub atominEffu

	c = (max(20,min(255, track_values(18)*255)))
	
	color cbWhite
	// fuckings to zerppa for "INVERTED-Y-AXIS-WHEN-DRAWING-text-to-image-SHIT!"
	text 5, -100, track_values(18)
	
	if gCurrentScene = "invert" then
		maskImage imgFadeMask, 255, 255, 255 : maskImage imgDemoLogo, 255, 255, 255 : drawToImage imgFadeMask : color 0,0,0  : box 1,1,imageWidth(imgFadeMask)-1, imageHeight(imgFadeMask)-1  : color  c, c, c  : box 1,1,imageWidth(imgDemoLogo)-1, imageHeight(imgDemoLogo)-1 : drawImage imgDemoLogo, 1, 1 : drawToImage gBuffer : maskImage imgDemoLogo, 0, 0, 0 : maskImage imgFadeMask, 0, 0, 0
		if c>20 then drawImage imgFadeMask, 160-imageWidth(imgDemoLogo)/2, 50
	else
		maskImage imgFadeMask, 255, 255, 255 : maskImage imgSmallLogo, 255, 255, 255 : drawToImage imgFadeMask : color 0,0,0  : box 1,1,imageWidth(imgFadeMask)-1, imageHeight(imgFadeMask)-1  : color  c, c, c  : box 1,1,imageWidth(imgSmallLogo)-1, imageHeight(imgSmallLogo)-1 : drawImage imgSmallLogo, 1, 1 : drawToImage gBuffer : maskImage imgSmallLogo, 0, 0, 0 : maskImage imgFadeMask, 0, 0, 0
		if c>20 then drawImage imgFadeMask, 15, 122
	endif
return

toinenEffu:
	ypos# = -bars*100.0
	drawImage imgGarbage, 0, ypos mod imageHeight(imgGarbage)
	drawImage imgGarbage, 0, ypos mod imageHeight(imgGarbage) + imageHeight(imgGarbage)
return


// fisheyee distance
// #define a_dist(_px,_py,_pz) (sqrt((_px)^2+(_py)^2+(_pz)^2))

atominEffu:
    //kamera pyörii jonkun jännän jutskan ympärillä\ linejä\ bucketointi lopuksi jos tarvii
    //y pienenee ylöspäin ja z kasvaa eteenpäin x kasvaa oikealle, kai
    color 200,0,0
    a_cDist#=-track_values(0)*20//15+sin(bars*360)*10
    a_cAng#=track_values(1)*700//bars*90
    a_cRot#=track_values(2)*700
    a_cAlt#=track_values(3)*10-5
    a_cPitch#=track_values(4)*700
    a_cRoll#=track_values(5)*700
    a_cX#=track_values(6)*50
    a_cY#=track_values(7)*50
    a_cZ#=track_values(8)*-50
    a_cFog#=track_values(9)+0.1
    a_shipX#=track_values(10)*50
    a_shipY#=track_values(11)*50
    a_shipZ#=track_values(12)*50
    a_gRough#=track_values(13)*0.5
    
    lock image(gBuffer)
    a_r=200

	gridscale#=2

    a_gMovedX=a_cX/gridscale
    a_gMovedZ=a_cZ/gridscale

    for x=-8-a_gMovedX to 8-a_gMovedX   
        a_gRough2#=min(1,(x*0.2)^2)*a_gRough
            for z=-8-a_gMovedZ to 8-a_gMovedZ

            px#=(x+1)*gridscale
            pz#=z*gridscale
            py#=(sin(px*100)+sin(pz*100))*a_gRough2
            
            px2#=px-gridscale
            pz2#=pz
            py2#=(sin(px2*100)+sin(pz2*100))*a_gRough2

            gosub a_smart_line

            px#=x*gridscale
            pz#=(z+1)*gridscale
            py#=(sin(px*100)+sin(pz*100))*a_gRough2
            
            px2#=px
            pz2#=pz-gridscale
            py2#=(sin(px2*100)+sin(pz2*100))*a_gRough2

            gosub a_smart_line

        next z
    next x
	

    //test rendering an object
    a_mx=peekInt(testobj,0)
    a_my=peekInt(testobj,4)
    a_mz=peekInt(testobj,8)
    a_size=MEMBlockSize(a_mx)
    
    a_cX+a_shipX
    a_cY+a_shipY
    a_cZ+a_shipZ

    for i=0 to a_size-8 step 8
		
        px#=peekFloat(a_mx,i)
        py#=peekFloat(a_my,i)
        pz#=peekFloat(a_mz,i)
        i2=i+4
        px2#=peekFloat(a_mx,i2)
        py2#=peekFloat(a_my,i2)
        pz2#=peekFloat(a_mz,i2)
        
        //gosub a_line_with_fog
        gosub a_smart_line
    next i
    
    unlock
return

a_dot:
    gosub a_kamera
    pd#=(sqrt((px)^2+(py)^2+(pz)^2))
    if pz<0.2 then dot px/pd*180.0+160,py/pd*180.0+90
return

a_line:
    gosub a_kamera
    gosub a_kamera2
    pd#=(sqrt((px)^2+(py)^2+(pz)^2))
    pd2#=(sqrt((px2)^2+(py2)^2+(pz2)^2))
    if pz<0.2 and pz2<0.2 then line px/pd#*180.0+160,py/pd#*180.0+90,px2/pd2#*180.0+160,py2/pd2#*180.0+90
return

a_line_with_fog:
    gosub a_kamera
    gosub a_kamera2
    pd#=(sqrt((px)^2+(py)^2+(pz)^2))
    pd2#=(sqrt((px2)^2+(py2)^2+(pz2)^2))
    _d#=(pd+pd2)*2*a_cFog
    color (max(20,min(255, a_r/_d*2-_d))),(max(20,min(255, a_g/_d*2-_d))),(max(20,min(255, a_b/_d*2-_d)))
    if pz<0.2 and pz2<0.2 then line px/pd#*180.0+160,py/pd#*180.0+90,px2/pd2#*180.0+160,py2/pd2#*180.0+90
return

_s_a_line_with_fog: //takes _-prefixed input-variables instead
    gosub _s_a_kamera
    gosub _s_a_kamera2
    pd#=(sqrt((px)^2+(py)^2+(pz)^2))
    pd2#=(sqrt((px2)^2+(py2)^2+(pz2)^2))
    _d#=(pd+pd2)*2*a_cFog
    color (max(20,min(255, a_r/_d*2-_d))),(max(20,min(255, a_g/_d*2-_d))),(max(20,min(255, a_b/_d*2-_d)))
    if pz<0.2 and pz2<0.2 then line px/pd#*180.0+160,py/pd#*180.0+90,px2/pd2#*180.0+160,py2/pd2#*180.0+90
return

a_smart_line:
    _px#=px//do this just to avoid another copy of camera function
    _py#=py
    _pz#=pz
    _s_d=(sqrt((px-px2)^2+(py-py2)^2+(pz-pz2)^2))*6
    px=(px+px2)/2
    py=(py+py2)/2
    pz=(pz+pz2)/2
    gosub a_kamera
    _s_d=_s_d/((sqrt((px)^2+(py)^2+(pz)^2))^2*0.2+0.5)+1

    if _s_d>1 then
        _dx#=(px2-_px)/_s_d
        _dy#=(py2-_py)/_s_d
        _dz#=(pz2-_pz)/_s_d
        _s_px#=_px
        _s_py#=_py
        _s_pz#=_pz
        for _s_i=1 to _s_d-1
            _px2#=_s_px+_dx*_s_i
            _py2#=_s_py+_dy*_s_i
            _pz2#=_s_pz+_dz*_s_i
            _s_i2=_s_i+1
            gosub _s_a_line_with_fog
            _px=_s_px+_dx*_s_i2
            _py=_s_py+_dy*_s_i2
            _pz=_s_pz+_dz*_s_i2
            gosub _s_a_line_with_fog
        next _s_i
    else
        px=_px
        py=_py
        pz=_pz
        gosub a_line_with_fog
    endif
return


a_kamera:
    //rotate around origin and translate back
    px=px+cos(a_cAng-90)*a_cDist+a_cX
    pz=pz-sin(a_cAng-90)*a_cDist+a_cZ
    py=py+a_cAlt+a_cY
    a_a#=-getAngle(0,0,px,pz)
    a_d#=-distance(0,0,px,pz)
    px=cos(a_a+a_cAng)*a_d
    pz=-sin(a_a+a_cAng)*a_d
    //rotate camera
    a_a#=getAngle(0,0,px,pz)
    a_d#=distance(0,0,px,pz)
    px=cos(a_a+a_cRot)*a_d
    pz=-sin(a_a+a_cRot)*a_d
    //pitch
    a_a#=getAngle(0,0,pz,py)
    a_d#=distance(0,0,pz,py)
    pz=cos(a_a+a_cPitch)*a_d
    py=-sin(a_a+a_cPitch)*a_d
    //roll
    a_a#=getAngle(0,0,px,py)
    a_d#=distance(0,0,px,py)
    px=cos(a_a+a_cRoll)*a_d
    py=-sin(a_a+a_cRoll)*a_d
return


a_kamera2: //should be identical to a_kamera, except for variable names
    //rotate around origin and translate back
    px2=px2+cos(a_cAng-90)*a_cDist+a_cX
    pz2=pz2-sin(a_cAng-90)*a_cDist+a_cZ
    py2=py2+a_cAlt+a_cY
    a_a#=-getAngle(0,0,px2,pz2)
    a_d#=-distance(0,0,px2,pz2)
    px2=cos(a_a+a_cAng)*a_d
    pz2=-sin(a_a+a_cAng)*a_d
    //rotate camera
    a_a#=getAngle(0,0,px2,pz2)
    a_d#=distance(0,0,px2,pz2)
    px2=cos(a_a+a_cRot)*a_d
    pz2=-sin(a_a+a_cRot)*a_d
    //pitch
    a_a#=getAngle(0,0,pz2,py2)
    a_d#=distance(0,0,pz2,py2)
    pz2=cos(a_a+a_cPitch)*a_d
    py2=-sin(a_a+a_cPitch)*a_d
    //roll
    a_a#=getAngle(0,0,px2,py2)
    a_d#=distance(0,0,px2,py2)
    px2=cos(a_a+a_cRoll)*a_d
    py2=-sin(a_a+a_cRoll)*a_d
return

//takes _-prefixed input-variables instead
_s_a_kamera:
    //rotate around origin and translate back
    px=_px+cos(a_cAng-90)*a_cDist+a_cX
    pz=_pz-sin(a_cAng-90)*a_cDist+a_cZ
    py=_py+a_cAlt+a_cY
    a_a#=-getAngle(0,0,px,pz)
    a_d#=-distance(0,0,px,pz)
    px=cos(a_a+a_cAng)*a_d
    pz=-sin(a_a+a_cAng)*a_d
    //rotate camera
    a_a#=getAngle(0,0,px,pz)
    a_d#=distance(0,0,px,pz)
    px=cos(a_a+a_cRot)*a_d
    pz=-sin(a_a+a_cRot)*a_d
    //pitch
    a_a#=getAngle(0,0,pz,py)
    a_d#=distance(0,0,pz,py)
    pz=cos(a_a+a_cPitch)*a_d
    py=-sin(a_a+a_cPitch)*a_d
    //roll
    a_a#=getAngle(0,0,px,py)
    a_d#=distance(0,0,px,py)
    px=cos(a_a+a_cRoll)*a_d
    py=-sin(a_a+a_cRoll)*a_d
return

//takes _-prefixed input-variables instead
_s_a_kamera2: //should be identical to a_kamera, except for variable names
    //rotate around origin and translate back
    px2=_px2+cos(a_cAng-90)*a_cDist+a_cX
    pz2=_pz2-sin(a_cAng-90)*a_cDist+a_cZ
    py2=_py2+a_cAlt+a_cY
    a_a#=-getAngle(0,0,px2,pz2)
    a_d#=-distance(0,0,px2,pz2)
    px2=cos(a_a+a_cAng)*a_d
    pz2=-sin(a_a+a_cAng)*a_d
    //rotate camera
    a_a#=getAngle(0,0,px2,pz2)
    a_d#=distance(0,0,px2,pz2)
    px2=cos(a_a+a_cRot)*a_d
    pz2=-sin(a_a+a_cRot)*a_d
    //pitch
    a_a#=getAngle(0,0,pz2,py2)
    a_d#=distance(0,0,pz2,py2)
    pz2=cos(a_a+a_cPitch)*a_d
    py2=-sin(a_a+a_cPitch)*a_d
    //roll
    a_a#=getAngle(0,0,px2,py2)
    a_d#=distance(0,0,px2,py2)
    px2=cos(a_a+a_cRoll)*a_d
    py2=-sin(a_a+a_cRoll)*a_d
return




